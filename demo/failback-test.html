<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>HLS.js Failback Loader Test</title>
    <style>
      * {
        box-sizing: border-box;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background: #1a1a2e;
        color: #eee;
      }

      h1 {
        color: #00d4ff;
        margin-bottom: 10px;
      }

      .subtitle {
        color: #888;
        margin-bottom: 20px;
      }

      .container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
      }

      @media (max-width: 900px) {
        .container {
          grid-template-columns: 1fr;
        }
      }

      .video-section {
        background: #16213e;
        padding: 20px;
        border-radius: 10px;
      }

      video {
        width: 100%;
        background: #000;
        border-radius: 5px;
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        margin-top: 15px;
      }

      .stat-box {
        background: #0f3460;
        padding: 15px;
        border-radius: 8px;
        text-align: center;
      }

      .stat-box .value {
        font-size: 24px;
        font-weight: bold;
        color: #00d4ff;
      }

      .stat-box .label {
        font-size: 12px;
        color: #888;
        margin-top: 5px;
      }

      /* Failback State Display */
      .state-section {
        background: #0f3460;
        padding: 15px;
        border-radius: 8px;
        margin-top: 15px;
      }

      .state-section h4 {
        color: #00d4ff;
        margin: 0 0 10px 0;
        font-size: 14px;
      }

      #failback-state {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .state-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .state-label {
        color: #888;
        font-size: 12px;
      }

      .state-value {
        font-family: 'Monaco', 'Menlo', monospace;
        font-size: 12px;
        color: #00ff88;
      }

      .state-value.permanent {
        color: #ff4757;
        font-weight: bold;
      }

      .state-value.normal {
        color: #00ff88;
      }

      /* Control Buttons */
      .control-buttons {
        display: flex;
        gap: 10px;
        margin-top: 15px;
      }

      .btn {
        padding: 8px 16px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 12px;
        font-weight: bold;
        transition: all 0.2s;
      }

      .btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      .btn-reset {
        background: #ffaa00;
        color: #1a1a2e;
      }

      .btn-destroy {
        background: #e94560;
        color: white;
      }

      .btn-reinit {
        background: #00d4ff;
        color: #1a1a2e;
      }

      .logs-section {
        background: #16213e;
        padding: 20px;
        border-radius: 10px;
        display: flex;
        flex-direction: column;
      }

      .logs-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }

      .logs-header h3 {
        margin: 0;
        color: #00d4ff;
      }

      .clear-btn {
        background: #e94560;
        color: white;
        border: none;
        padding: 5px 15px;
        border-radius: 5px;
        cursor: pointer;
      }

      #logs {
        background: #0a0a15;
        padding: 15px;
        border-radius: 8px;
        height: 400px;
        overflow-y: auto;
        font-family: 'Monaco', 'Menlo', monospace;
        font-size: 12px;
        flex-grow: 1;
      }

      .log-entry {
        padding: 8px 10px;
        margin-bottom: 5px;
        border-radius: 4px;
        border-left: 3px solid;
      }

      .log-info {
        background: #1a1a3e;
        border-color: #00d4ff;
        color: #00d4ff;
      }

      .log-success {
        background: #1a3e1a;
        border-color: #00ff88;
        color: #00ff88;
      }

      .log-failback {
        background: #3e3a1a;
        border-color: #ffaa00;
        color: #ffaa00;
      }

      .log-error {
        background: #3e1a1a;
        border-color: #ff4444;
        color: #ff4444;
      }

      .log-time {
        color: #666;
        margin-right: 10px;
      }

      .log-url {
        color: #888;
        font-size: 11px;
        margin-top: 3px;
        word-break: break-all;
      }

      .legend {
        display: flex;
        gap: 20px;
        margin-top: 15px;
        flex-wrap: wrap;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
      }

      .legend-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
      }

      .legend-dot.direct {
        background: #00ff88;
      }

      .legend-dot.failback {
        background: #ffaa00;
      }

      .legend-dot.error {
        background: #ff4444;
      }

      .legend-dot.info {
        background: #00d4ff;
      }

      .config-section {
        background: #16213e;
        padding: 20px;
        border-radius: 10px;
        margin-bottom: 20px;
        grid-column: 1 / -1;
      }

      .config-section h3 {
        color: #00d4ff;
        margin: 0 0 15px 0;
      }

      .config-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 15px;
      }

      .config-box {
        background: #0f3460;
        padding: 15px;
        border-radius: 8px;
      }

      .config-box h4 {
        color: #ffaa00;
        margin: 0 0 10px 0;
        font-size: 14px;
      }

      .config-box .value {
        font-family: 'Monaco', 'Menlo', monospace;
        font-size: 12px;
        color: #00ff88;
        word-break: break-all;
      }

      .config-box .label {
        color: #888;
        font-size: 11px;
        margin-top: 5px;
      }

      .host-list {
        list-style: none;
        padding: 0;
        margin: 0;
      }

      .host-list li {
        padding: 5px 0;
        border-bottom: 1px solid #1a1a3e;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .host-list li:last-child {
        border-bottom: none;
      }

      .priority-badge {
        background: #e94560;
        color: white;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 10px;
        font-weight: bold;
      }

      .host-name {
        font-family: 'Monaco', 'Menlo', monospace;
        font-size: 12px;
        color: #00ff88;
      }

      .dns-status {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 4px;
        font-size: 11px;
        margin-left: 10px;
      }

      .dns-status.loading {
        background: #3e3a1a;
        color: #ffaa00;
      }

      .dns-status.success {
        background: #1a3e1a;
        color: #00ff88;
      }

      .dns-status.error {
        background: #3e1a1a;
        color: #ff4444;
      }
    </style>
    <script src="../dist/hls.js"></script>
  </head>

  <body>
    <h1>FailbackLoader Test</h1>
    <p class="subtitle">
      Testing automatic failback from broken CDN to backup server
    </p>

    <div class="container">
      <!-- Failback Configuration Section -->
      <div class="config-section">
        <h3>Failback Configuration</h3>
        <div class="config-grid">
          <div class="config-box">
            <h4>DNS Configuration</h4>
            <div class="value">fb.turoktv.com</div>
            <div class="label">DNS TXT Record Domain</div>
            <div style="margin-top: 10px">
              <div class="value" style="color: #888">
                dns.google, dns.yandex.net
              </div>
              <div class="label">
                DoH Providers (parallel requests, first wins)
              </div>
            </div>
          </div>

          <div class="config-box">
            <h4>
              DNS Hosts
              <span id="dns-status" class="dns-status loading">loading...</span>
              <button
                onclick="fetchDnsHostsForDisplay()"
                style="
                  margin-left: 10px;
                  background: #0f3460;
                  border: 1px solid #00d4ff;
                  color: #00d4ff;
                  padding: 2px 8px;
                  border-radius: 4px;
                  cursor: pointer;
                  font-size: 11px;
                "
              >
                Refresh
              </button>
            </h4>
            <ul class="host-list" id="dns-hosts-list">
              <li>
                <span class="host-name" style="color: #888"
                  >Fetching from DNS...</span
                >
              </li>
            </ul>
            <div class="label">
              Hosts from DNS TXT record (priority order from GeoDNS)
            </div>
          </div>

          <div class="config-box">
            <h4>Fallback Host (if DNS fails)</h4>
            <ul class="host-list">
              <li>
                <span class="priority-badge">#1</span>
                <span class="host-name">failback.turkserial.co</span>
              </li>
            </ul>
            <div class="label">Hardcoded fallback if DNS resolution fails</div>
          </div>

          <div class="config-box">
            <h4>Test Page Config (staticHosts)</h4>
            <ul class="host-list">
              <li>
                <span class="priority-badge">#1</span>
                <span class="host-name">test-streams.mux.dev</span>
              </li>
            </ul>
            <div class="label">Static hosts override DNS for this test</div>
          </div>
        </div>
      </div>

      <!-- Chaos Control Section -->
      <div
        class="config-section"
        style="border: 2px solid #e94560; background: #2a1a1a"
      >
        <h3 style="color: #ff4444">ðŸ”¥ Chaos Controls (Simulate Failures)</h3>
        <p style="color: #aaa; font-size: 13px; margin-bottom: 15px">
          These controls sabotage <code>test-streams.mux.dev</code> requests to
          force failback.
        </p>

        <div class="control-buttons">
          <button
            class="btn"
            style="background: #333; color: #fff"
            onclick="setChaosMode('none')"
            id="chaos-none"
          >
            Normal Mode
          </button>
          <button
            class="btn"
            style="background: #e94560; color: #fff"
            onclick="setChaosMode('500')"
            id="chaos-500"
          >
            Simulate 500 Errors
          </button>
          <button
            class="btn"
            style="background: #ff4444; color: #fff"
            onclick="setChaosMode('404')"
            id="chaos-404"
          >
            Simulate 404 Errors
          </button>
          <button
            class="btn"
            style="background: #ffaa00; color: #000"
            onclick="setChaosMode('timeout')"
            id="chaos-timeout"
          >
            Simulate Timeouts
          </button>
        </div>
        <div
          id="chaos-status"
          style="
            margin-top: 10px;
            color: #ffaa00;
            font-size: 12px;
            font-weight: bold;
          "
        >
          Current Mode: Normal
        </div>
      </div>

      <div class="video-section">
        <video id="video" controls></video>

        <div class="stats">
          <div class="stat-box">
            <div class="value" id="stat-direct">0</div>
            <div class="label">Direct Success</div>
          </div>
          <div class="stat-box">
            <div class="value" id="stat-failback">0</div>
            <div class="label">Failback Success</div>
          </div>
          <div class="stat-box">
            <div class="value" id="stat-errors">0</div>
            <div class="label">Errors</div>
          </div>
        </div>

        <div class="legend">
          <div class="legend-item">
            <div class="legend-dot direct"></div>
            Direct load
          </div>
          <div class="legend-item">
            <div class="legend-dot failback"></div>
            Failback used
          </div>
          <div class="legend-item">
            <div class="legend-dot error"></div>
            Error
          </div>
          <div class="legend-item">
            <div class="legend-dot info"></div>
            Info
          </div>
        </div>

        <!-- Failback State Section -->
        <div class="state-section">
          <h4>Failback State (Live)</h4>
          <div id="failback-state">
            <div class="state-item">
              <span class="state-label">Mode:</span>
              <span class="state-value normal">Normal</span>
            </div>
            <div class="state-item">
              <span class="state-label">Consecutive Failures:</span>
              <span class="state-value">0/2</span>
            </div>
            <div class="state-item">
              <span class="state-label">Buffer:</span>
              <span class="state-value">0s</span>
            </div>
          </div>

          <div class="control-buttons">
            <button class="btn btn-reset" onclick="resetState()">
              Reset State
            </button>
            <button class="btn btn-destroy" onclick="destroyPlayer()">
              Destroy
            </button>
            <button class="btn btn-reinit" onclick="initPlayer()">
              Re-init
            </button>
          </div>
        </div>
      </div>

      <div class="logs-section">
        <div class="logs-header">
          <h3>ðŸ“‹ Event Log</h3>
          <button class="clear-btn" onclick="clearLogs()">Clear</button>
        </div>
        <div id="logs"></div>
      </div>
    </div>

    <script>
      const video = document.getElementById('video');
      const logsEl = document.getElementById('logs');

      let stats = { direct: 0, failback: 0, errors: 0 };

      // ==========================================
      // CHAOS MONKEY PATCHER (XHR Interceptor)
      // ==========================================
      let chaosMode = 'none'; // none, 500, 404, timeout
      const OriginalXHR = window.XMLHttpRequest;

      function setChaosMode(mode) {
        chaosMode = mode;
        document.getElementById('chaos-status').textContent =
          `Current Mode: ${mode.toUpperCase()} (Targeting test-streams.mux.dev)`;

        // Update UI active state
        ['none', '500', '404', 'timeout'].forEach((m) => {
          const btn = document.getElementById(`chaos-${m}`);
          if (m === mode) {
            btn.style.opacity = '1';
            btn.style.transform = 'scale(1.05)';
            btn.style.boxShadow = '0 0 10px rgba(255,0,0,0.5)';
          } else {
            btn.style.opacity = '0.7';
            btn.style.transform = 'none';
            btn.style.boxShadow = 'none';
          }
        });

        log(`ðŸ”¥ Chaos Mode set to: ${mode.toUpperCase()}`, 'failback');
      }

      // Patch XHR to simulate errors
      window.XMLHttpRequest = class MockXHR extends OriginalXHR {
        open(method, url, ...args) {
          this._url = url;
          super.open(method, url, ...args);
        }

        send(body) {
          // Only target the primary host AND exclude failback requests
          // We identify failback requests by the ?failback=true parameter added by transformUrl
          const isTargetHost =
            this._url && this._url.includes('test-streams.mux.dev');
          const isFailbackRequest =
            this._url && this._url.includes('failback=true');

          if (chaosMode !== 'none' && isTargetHost && !isFailbackRequest) {
            console.warn(
              `[Chaos] Intercepting request to ${this._url} with mode ${chaosMode}`
            );

            if (chaosMode === 'timeout') {
              // Do nothing - request will hang until default timeout
              // Hls.js will interpret this as a timeout
              log(`[Chaos] Simulating TIMEOUT for ${this._url}`, 'error');
              return;
            }

            // For status errors, we need to let the browser process it a bit or just spoof response
            // Easy way: spoof properties
            Object.defineProperty(this, 'status', {
              value: parseInt(chaosMode),
            });
            Object.defineProperty(this, 'statusText', {
              value: 'Simulated Chaos Error',
            });
            Object.defineProperty(this, 'readyState', { value: 4 });

            // Trigger error asynchronously
            setTimeout(() => {
              log(
                `[Chaos] Simulating ${chaosMode} error for ${this._url}`,
                'error'
              );
              if (this.onreadystatechange) this.onreadystatechange();
              // Also trigger onload/onerror if they exist
              if (parseInt(chaosMode) >= 400 && this.onerror) this.onerror();
              else if (this.onload) this.onload();
            }, 100);

            return;
          }

          super.send(body);
        }
      };

      // Initialize UI
      setChaosMode('none');
      // ==========================================

      // Fetch DNS hosts for display
      async function fetchDnsHostsForDisplay() {
        const statusEl = document.getElementById('dns-status');
        const listEl = document.getElementById('dns-hosts-list');

        // Show loading state
        statusEl.textContent = 'loading...';
        statusEl.className = 'dns-status loading';
        listEl.innerHTML =
          '<li><span class="host-name" style="color: #888;">Fetching from DNS...</span></li>';

        // Helper for fetch with timeout
        async function fetchWithTimeout(url, options, timeoutMs = 5000) {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
          try {
            const response = await fetch(url, {
              ...options,
              signal: controller.signal,
            });
            clearTimeout(timeoutId);
            return response;
          } catch (e) {
            clearTimeout(timeoutId);
            throw e;
          }
        }

        // Try multiple DoH providers in parallel - first success wins
        const providers = [
          'https://dns.google/resolve',
          'https://common.dot.dns.yandex.net/dns-query',
        ];

        try {
          const requests = providers.map((provider) =>
            fetchWithTimeout(
              `${provider}?name=fb.turoktv.com&type=TXT`,
              { headers: { Accept: 'application/dns-json' } },
              3000
            ).then((r) => {
              if (!r.ok) throw new Error('Not OK');
              return r;
            })
          );

          // Promise.any polyfill for older browsers
          const promiseAny = (promises) =>
            new Promise((resolve, reject) => {
              let pending = promises.length;
              if (pending === 0) {
                reject(new Error('All failed'));
                return;
              }
              promises.forEach((p) =>
                Promise.resolve(p)
                  .then(resolve)
                  .catch(() => {
                    if (--pending === 0) reject(new Error('All failed'));
                  })
              );
            });

          const response = await promiseAny(requests);

          const data = await response.json();

          if (data.Status !== 0 || !data.Answer) {
            throw new Error('No DNS records found');
          }

          const hosts = data.Answer.filter((a) => a.type === 16)
            .map((a) => a.data.replace(/^"|"$/g, ''))
            .filter((h) => h.trim().length > 0);

          if (hosts.length === 0) {
            throw new Error('No hosts in TXT records');
          }

          statusEl.textContent = 'resolved';
          statusEl.className = 'dns-status success';

          listEl.innerHTML = hosts
            .map(
              (host, i) => `
          <li>
            <span class="priority-badge">#${i + 1}</span>
            <span class="host-name">${host}</span>
          </li>
        `
            )
            .join('');
        } catch (e) {
          statusEl.textContent = 'failed';
          statusEl.className = 'dns-status error';
          listEl.innerHTML =
            '<li><span class="host-name" style="color: #ff4444;">DNS resolution failed: ' +
            e.message +
            '</span></li>';
        }
      }

      // Fetch DNS hosts on page load
      fetchDnsHostsForDisplay();

      function updateStats() {
        document.getElementById('stat-direct').textContent = stats.direct;
        document.getElementById('stat-failback').textContent = stats.failback;
        document.getElementById('stat-errors').textContent = stats.errors;
      }

      function log(message, type = 'info', url = null) {
        const div = document.createElement('div');
        div.className = `log-entry log-${type}`;

        const time = new Date().toLocaleTimeString();
        let html = `<span class="log-time">${time}</span>${message}`;
        if (url) {
          // Extract path after host for better identification
          try {
            const u = new URL(url);
            const pathParts = u.pathname.split('/').filter(Boolean);
            // Show last 3 path parts for context (e.g., url_462/193039199_mp4_h264_aac_hd_7.ts)
            const shortPath = pathParts.slice(-3).join('/');
            html +=
              `<div class="log-url">${u.host}/.../` + shortPath + `</div>`;
          } catch {
            html += `<div class="log-url">${url}</div>`;
          }
        }
        div.innerHTML = html;

        logsEl.appendChild(div);
        logsEl.scrollTop = logsEl.scrollHeight;
      }

      function clearLogs() {
        logsEl.innerHTML = '';
        stats = { direct: 0, failback: 0, errors: 0 };
        updateStats();
      }

      // Real CDN hosts - failback.turkserial.co is the backup
      const mainHost = 'hls.armdb.org';
      const backupHost = 'failback.turkserial.co';

      // Import failback state functions
      // Add safety checks for Hls availability
      const getFailbackState = Hls
        ? Hls.getFailbackState
        : () => ({ consecutiveFailures: 0 });
      const resetFailbackState = Hls ? Hls.resetFailbackState : () => {};
      const setRecoveryVideoElement = Hls
        ? Hls.setRecoveryVideoElement
        : () => {};
      const destroyFailbackState = Hls ? Hls.destroyFailbackState : () => {};

      let hls = null;

      function initPlayer() {
        if (!Hls || !Hls.isSupported()) {
          log('HLS.js not supported in this browser', 'error');
          return;
        }

        log('HLS.js initialized, FailbackLoader enabled by default', 'info');

        hls = new Hls({
          debug: true, // Enable debug logs to see FailbackLoader messages in console
          failbackConfig: {
            // override DNS lookup with static hosts for reliable test environment
            // bypasses CORS issues with DNS provider from localhost
            staticHosts: ['test-streams.mux.dev'],

            // Disable Cache-Control header to avoid CORS errors on mux.dev
            disableCacheControlHeader: true,

            // Custom transform to:
            // 1. Point everything to mux.dev (since we only have one test stream)
            // 2. Add ?failback=true so our Chaos Monkey knows to let this request through
            transformUrl: (url, attempt) => {
              try {
                const u = new URL(url);
                // Always use mux.dev for this test
                u.hostname = 'test-streams.mux.dev';

                // Add a marker so the MockXHR knows this is a "secure" failback request
                // and shouldn't be sabotaged
                u.searchParams.set('failback', 'true');

                return u.toString();
              } catch (e) {
                return null;
              }
            },

            onSuccess: (url, wasFailback, attempt) => {
              if (wasFailback) {
                stats.failback++;
                updateStats();
                log(`âœ… SUCCESS (via failback #${attempt})`, 'success', url);
              } else {
                stats.direct++;
                updateStats();
                log('âœ… SUCCESS (direct load)', 'success', url);
              }
              // Update state display
              updateFailbackStateDisplay();
            },

            onFailback: (originalUrl, failbackUrl, attempt) => {
              log(
                `âš¡ FAILBACK #${attempt}: Switching to backup server`,
                'failback',
                failbackUrl
              );
              // Update state display
              updateFailbackStateDisplay();
            },

            onAllFailed: (originalUrl, attempts) => {
              stats.errors++;
              updateStats();
              log(
                `âŒ FAILED: All ${attempts} attempts exhausted`,
                'error',
                originalUrl
              );
            },
          },
        });

        // Use CORS-enabled public test stream from Mux
        // Original armdb.org stream blocks localhost CORS
        hls.loadSource('https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8');
        hls.attachMedia(video);

        // Enable automatic CDN recovery by setting video element
        setRecoveryVideoElement(hls.config, video);
        log('ðŸ”„ Auto-recovery enabled (video element set)', 'info');

        hls.on(Hls.Events.MANIFEST_PARSED, function () {
          log('ðŸ“º Manifest loaded, ready to play', 'info');
          video.play().catch(() => {
            log('Click video to start playback', 'info');
          });
        });

        hls.on(Hls.Events.ERROR, function (event, data) {
          if (data.fatal) {
            stats.errors++;
            updateStats();
            log(`ðŸ’€ Fatal error: ${data.details}`, 'error');
          }
        });

        // Update state display periodically
        setInterval(updateFailbackStateDisplay, 1000);
      }

      function updateFailbackStateDisplay() {
        const stateEl = document.getElementById('failback-state');
        if (!stateEl || !hls || !hls.config) return;

        const state = getFailbackState(hls.config);
        const modeClass = state.permanentMode ? 'permanent' : 'normal';
        stateEl.innerHTML = `
          <div class="state-item">
            <span class="state-label">Mode:</span>
            <span class="state-value ${modeClass}">${state.permanentMode ? 'PERMANENT FAILBACK' : 'Normal'}</span>
          </div>
          <div class="state-item">
            <span class="state-label">Consecutive Failures:</span>
            <span class="state-value">${state.consecutiveFailures}/${state.threshold}</span>
          </div>
          <div class="state-item">
            <span class="state-label">Buffer:</span>
            <span class="state-value">${(video.buffered.length ? video.buffered.end(video.buffered.length - 1) - video.currentTime : 0).toFixed(1)}s</span>
          </div>
      `;
      }

      function resetState() {
        if (!hls || !hls.config) return;
        resetFailbackState(hls.config);
        log('ðŸ”„ Failback state reset (will try original source)', 'info');
        updateFailbackStateDisplay();
      }

      function destroyPlayer() {
        if (hls) {
          hls.destroy();
          log('ðŸ›‘ Player destroyed', 'info');

          // Reset XHR Patcher to normal mode
          setChaosMode('none');

          // Clear UI state
          const stateEl = document.getElementById('failback-state');
          if (stateEl) {
            stateEl.innerHTML = `
            <div class="state-item"><span class="state-label">Status:</span><span class="state-value">Destroyed</span></div>
          `;
          }
        }
      }

      // Initialize player
      initPlayer();
    </script>
  </body>
</html>
